#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <time.h>
#include <string.h>
#include <fcntl.h>

#define MAX_HIDDEN_KEYS 80
#define MAX_ARRAY_SIZE 1000000

struct Metrics {
    int max;
    float avg;
    int hiddenKeys[MAX_HIDDEN_KEYS];
    int foundKeys;
    pid_t pid;
    pid_t ppid;
    int returnArg;
};

//generates L (an array 20,000+ positive numbers)
void generate_input_file(const char *filename, int L) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        perror("File open failed");
        exit(1);
    }

    srand(time(NULL));
    int hidden_key_positions[MAX_HIDDEN_KEYS];
    for (int i = 0; i < MAX_HIDDEN_KEYS; i++) {
        hidden_key_positions[i] = rand() % L;
    }

    for (int i = 0; i < L; i++) {
        int is_hidden = 0;
        for (int j = 0; j < MAX_HIDDEN_KEYS; j++) {
            if (i == hidden_key_positions[j]) {
                fprintf(file, "%d\n", -(j + 1));
                is_hidden = 1;
                break;
            }
        }
        if (!is_hidden) {
            fprintf(file, "%d\n", rand() % 100 + 1);
        }
    }
    fclose(file);
} 

//reads the ints from the file generated by generate_input_file
//loads them into an array so data can be processed
void read_file_into_array(const char *filename, int *arr, int L) {
    FILE *file = fopen(filename, "r");
    for (int i = 0; i < L; i++) {
        fscanf(file, "%d", &arr[i]);
    }
    fclose(file);
}

//function is called by child processes to analyze a specific chunk of array
// finds:
//local max
//local avg
//records position of hidden (negative) keys it finds
struct Metrics process_segment(int *arr, int start, int end, int returnArg) {
    struct Metrics result = {.max = -99999, .avg = 0.0, .foundKeys = 0};
    int sum = 0;
    result.pid = getpid(); //stores process PID
    result.ppid = getppid(); //stores parent's PID
    result.returnArg = returnArg; //tracks unique return arg

    for (int i = start; i < end; i++) { //iterates through segment of array it is assigned
        if (arr[i] > result.max) result.max = arr[i]; //if current max > older max, updates max
        sum += arr[i];
        if (arr[i] < 0 && result.foundKeys < MAX_HIDDEN_KEYS) { //if neg num found, adds its index to hiddenKeys
            result.hiddenKeys[result.foundKeys++] = i;
        }
    }
    result.avg = (float)sum / (end - start); //computes avg of the segment
    return result; //returns result to the parent 
}

int main(int argc, char *argv[]) {

    //ensures only L, H, and PN are provided, more than 3 args are invalid
    if (argc < 4) {
        printf("Usage: %s <L> <H> <PN>\n", argv[0]);
        exit(1);
    }

    // atoi function turns string into int
    int L = atoi(argv[1]);
    int H = atoi(argv[2]);
    int PN = atoi(argv[3]);

    //sets up files to write results to results.txt
    const char *filename = "input.txt";
    const char *outputfile = "results.txt";
    FILE *out = fopen(outputfile, "w");
    if (!out) {
        perror("Failed to open results.txt");
        exit(1);
    }

    //creates file with L ints and 80 hiddenKeys
    generate_input_file(filename, L);

    //allocats memory and loads file contents into array
    int *arr = malloc(L * sizeof(int));
    read_file_into_array(filename, arr, L);

    int chunk_size = L / PN; //determines chunk size (how many array elements each child will handle)
    int pipes[PN][2]; //initializes a pipe for each process to talk back to parent

    //parent forks PN amount of children
    //each child recieves a diff segment of the array to analyze
    for (int i = 0; i < PN; i++) { 
        pipe(pipes[i]);
        pid_t pid = fork();

        //calculates range of the array to process
        if (pid == 0) {
            close(pipes[i][0]);
            int start = i * chunk_size;
            int end = (i == PN - 1) ? L : start + chunk_size;

            //processes the segment
            //finds max, avg, hiddenKey positions
            //sends result back through the pipe
            //sleeps for observability
            struct Metrics result = process_segment(arr, start, end, i + 1);
            write(pipes[i][1], &result, sizeof(result));
            close(pipes[i][1]);
            sleep(2);
            exit(i + 1); //exits with unique return code
        }
    }

    //variables to hold final combined results
    int global_max = -99999;
    float total_sum = 0;
    int total_hidden_reported = 0;

    //receives each child's metrics 
    for (int i = 0; i < PN; i++) {
        close(pipes[i][1]);
        struct Metrics result;
        read(pipes[i][0], &result, sizeof(result));
        close(pipes[i][0]);

        //logs the process info
        fprintf(out, "Hi Iâ€™m process %d with return arg %d and my parent is %d.\n", result.pid, result.returnArg, result.ppid);

        //logs up to H hiddenKey positions found across all children
        for (int j = 0; j < result.foundKeys && total_hidden_reported < H; j++) {
            fprintf(out, "Hi I am process %d with return arg %d and I found the hidden key in position A[%d].\n",
                    result.pid, result.returnArg, result.hiddenKeys[j]);
            total_hidden_reported++;
        }

        //tracks global max and total sum (for avg calculation)
        if (result.max > global_max) global_max = result.max;
        total_sum += result.avg * chunk_size;

        //waits for process to terminate and retrieves its return code
        int status;
        pid_t pid = wait(&status);
        if (WIFEXITED(status)) {
            int code = WEXITSTATUS(status);
        }
    }

    float global_avg = total_sum / L; //calculates and prints final global statistics 
    fprintf(out, "Max=%d, Avg=%.2f\n", global_max, global_avg);

    //closes the output file and frees memory
    fclose(out);
    free(arr);
    return 0;
}
